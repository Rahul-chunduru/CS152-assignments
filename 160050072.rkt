#lang racket
(require "declarations.rkt")

(provide buildTree calcForces moveparticles)

(define (belong area system)
  (cond (( null? system) system)
        (else (let* (( a (car system)))
                (let* (( x (vec-x (particle-posn a)))
                  ( y (vec-y (particle-posn a))))
                  (if ( and ( and ( < x (bbox-rux area)) ( >= x (bbox-llx area)))
                            (and (< y (bbox-ruy area )) (>= y (bbox-lly area))))
                      ( cons a ( belong area (cdr system))) ( belong area (cdr system))))))))
(define (filtere l)
  ( if (null?  l) '()
       ( if (null? (car l)) (filtere (cdr l))
            (cons (car l) (filtere (cdr l))))))
(define (mass system)
  (  if (null? system ) 0
        (+ (particle-mass (car system)) (mass (cdr system)))))
(define (centroid system)
  (   if (null? system) (vec 1 1)
         ( let* (( a ( particle-posn (car system)))
                 (b (centroid (cdr system)))
                 (ma ( particle-mass (car system)))
                 (mb ( mass (cdr system))))
            ( vec ( / (+ ( * ma ( vec-x a)) (* mb ( vec-x b))) (+ ma mb))
                  ( / (+ ( * ma ( vec-y a)) (* mb ( vec-y b))) (+ ma mb))))))

(define (buildTree area  system)
  ( cond (( null? system ) '())
         (( null? (cdr system)) (gnode (particle-mass (car system) ) (particle-posn (car system)) '()))
         (else (let* (( c1 ( bbox ( bbox-llx area) ( bbox-lly area) (/ (+ ( bbox-llx area) ( bbox-rux area)) 2)
                        (/ (+ ( bbox-lly area) ( bbox-ruy area)) 2)))
            ( c2 ( bbox ( bbox-llx area) (/ (+ ( bbox-lly area) ( bbox-ruy area)) 2)
           ( /  (+ ( bbox-llx area) ( bbox-rux area)) 2)  ( bbox-ruy area) ))
            ( c3 ( bbox ( /  (+ ( bbox-llx area) ( bbox-rux area)) 2) (/ (+ ( bbox-lly area) ( bbox-ruy area)) 2)
                        ( bbox-rux area)  ( bbox-ruy area) ))
            ( c4 ( bbox ( /  (+ ( bbox-llx area) ( bbox-rux area)) 2)
                        ( bbox-lly area)  ( bbox-rux area) (/ (+ ( bbox-lly area) ( bbox-ruy area)) 2) ))
            (l1 ( belong c1 system))
            (l2 ( belong c2 system))
            (l3 ( belong c3 system))
            (l4 ( belong c4 system))
            (A (buildTree  c1 l1))
            (B (buildTree  c2 l2))
            (C (buildTree  c3 l3))
            (D (buildTree  c4 l4)))
                 (gnode (mass system)
                        (centroid system)
                        (filtere (list   B C A D)))))))

(define (sq x) (* x x))
(define (distance r1 r2 ) 
  ( sqrt ( + ( sq (- ( vec-x r1) (vec-x r2))) 
             ( sq (- ( vec-y r1) (vec-y r2)))))) 
(define (force-between p1 p2)
  (if (= (distance (particle-posn p1) (particle-posn p2)) 0) (vec 0 0)
       (let* (
              (d (distance (particle-posn p1) (particle-posn p2)))
              (F ( * g (particle-mass p1) (particle-mass p2) 
      (/ 1 ( sq d)))))
              
         ( vec (/ ( * F (- (vec-x ( particle-posn p2)) (vec-x ( particle-posn p1))) )d )
               (/ ( * F (- (vec-y ( particle-posn p2)) (vec-y ( particle-posn p1))) )d))))) 
(define ( vector-sum v1 v2)
  (vec (+ (vec-x v1) (vec-x v2))
      (+ (vec-y v1) (vec-y v2))))
(define (calcForces area tree  system)
  
    (define (length-of  box)
    ( - ( bbox-rux box) (bbox-llx box)))
  (define (force-on   point tree l)
    (if ( null? (gnode-subtrees tree)) (force-between point (particle (gnode-mass tree) (gnode-posn tree) (vec 0 0)))
    (if ( > (/ (distance (particle-posn point) (gnode-posn tree)) l) theta) (force-between point 
                                                 (particle (gnode-mass tree) (gnode-posn tree) (vec 0 0)))
        (foldr vector-sum (vec 0 0) (map  (lambda(t)(force-on point t (/ l 2))) (gnode-subtrees tree)) ))))
     
  (map  (lambda(point)(force-on point  tree (length-of area)))    system))


(define (prod k v)
  (vec (* k (vec-x v)) (* k (vec-y v))))
(define (moveparticles  particles forces)
  (if (null? particles) '()
  (let* (( p (car particles))
         (F1 (car forces))
         (n-posn (vector-sum  (prod (* timeslice timeslice (/ .5 (particle-mass p))) F1) 
                                            ( vector-sum ( prod timeslice (particle-velocity p)) (particle-posn p))))
         (n-velocity ( vector-sum (prod (/ timeslice (particle-mass p)) F1) (particle-velocity p))))
    (cons ( particle (particle-mass p) n-posn n-velocity) (moveparticles (cdr particles) (cdr forces))))))
